use std::path::Path;

use anyhow::{Context, Result};
use tokio::fs;

use crate::config::WikiConfig;

const HEADER: &str = "#import \"include.typ\": *\n// Auto-generated by zk-lsp\n\n";

/// Regenerate link.typ from scratch by scanning note_dir.
pub async fn generate_link_typ(config: &WikiConfig) -> Result<()> {
    let mut ids = collect_note_ids(&config.note_dir).await?;
    ids.sort();
    write_link_typ(&config.link_file, &ids).await
}

/// Append a single entry to link.typ (used when a new note is created).
pub async fn add_entry(id: &str, config: &WikiConfig) -> Result<()> {
    let link_file = &config.link_file;
    if !link_file.exists() {
        // Bootstrap from scratch
        return generate_link_typ(config).await;
    }
    let content = fs::read_to_string(link_file).await?;
    let entry = format_entry(id);
    if content.contains(&entry) {
        return Ok(());
    }
    // Rebuild sorted to keep deterministic order
    let mut ids = collect_note_ids(&config.note_dir).await?;
    ids.sort();
    write_link_typ(link_file, &ids).await
}

/// Remove an entry from link.typ (used when a note is deleted).
pub async fn remove_entry(id: &str, config: &WikiConfig) -> Result<()> {
    let link_file = &config.link_file;
    if !link_file.exists() {
        return Ok(());
    }
    let content = fs::read_to_string(link_file).await?;
    let entry = format_entry(id);
    if !content.contains(&entry) {
        return Ok(());
    }
    let new_content: String = content
        .lines()
        .filter(|l| *l != entry.trim_end_matches('\n'))
        .collect::<Vec<_>>()
        .join("\n")
        + "\n";
    atomic_write(link_file, &new_content).await
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

async fn collect_note_ids(note_dir: &Path) -> Result<Vec<String>> {
    let mut ids = Vec::new();
    let mut entries = fs::read_dir(note_dir)
        .await
        .with_context(|| format!("reading note dir {}", note_dir.display()))?;
    while let Some(entry) = entries.next_entry().await? {
        let path = entry.path();
        if path.extension().and_then(|e| e.to_str()) != Some("typ") {
            continue;
        }
        if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
            if stem.len() == 10 && stem.chars().all(|c| c.is_ascii_digit()) {
                ids.push(stem.to_string());
            }
        }
    }
    Ok(ids)
}

fn format_entry(id: &str) -> String {
    format!("#zk_entry(\"{id}\", \"note/{id}.typ\")\n")
}

async fn write_link_typ(link_file: &Path, ids: &[String]) -> Result<()> {
    let mut content = HEADER.to_string();
    for id in ids {
        content.push_str(&format_entry(id));
    }
    atomic_write(link_file, &content).await
}

async fn atomic_write(dest: &Path, content: &str) -> Result<()> {
    let tmp = dest.with_extension("typ.tmp");
    fs::write(&tmp, content)
        .await
        .with_context(|| format!("writing tmp file {}", tmp.display()))?;
    fs::rename(&tmp, dest)
        .await
        .with_context(|| format!("renaming {} -> {}", tmp.display(), dest.display()))?;
    Ok(())
}
